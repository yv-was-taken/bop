use crate::apply::ApplyPlan;
use crate::detect::HardwareInfo;
use crate::error::{Error, Result};
use std::path::{Path, PathBuf};

const SERVICE_PATH: &str = "/etc/systemd/system/bop-powersave.service";

/// Generate a systemd oneshot service that applies sysfs settings on boot.
pub fn generate_service(hw: &HardwareInfo, plan: &ApplyPlan) -> Result<PathBuf> {
    let mut exec_lines = Vec::new();

    // Sysfs writes
    for write in &plan.sysfs_writes {
        // Use tee to write values (handles permission properly under systemd)
        exec_lines.push(format!(
            "ExecStart=/bin/bash -c 'echo \"{}\" > \"{}\"'",
            write.value, write.path
        ));
    }

    // ACPI wakeup sources (volatile, need to be re-applied each boot)
    for device in &plan.acpi_wakeup_disable {
        // Need to check state before toggling since it's a toggle interface
        exec_lines.push(format!(
            "ExecStart=/bin/bash -c 'grep -q \"^{}.*\\*enabled\" /proc/acpi/wakeup && echo \"{}\" > /proc/acpi/wakeup || true'",
            device, device
        ));
    }

    // WiFi power save
    if let Some(ref iface) = hw.network.wifi_interface {
        exec_lines.push(format!(
            "ExecStart=/usr/bin/iw dev {} set power_save on",
            iface
        ));
    }

    let unit = format!(
        r#"# Generated by bop (Battery Optimization Project)
# Do not edit manually -- use `bop apply` to regenerate or `bop revert` to remove

[Unit]
Description=bop power optimization (sysfs runtime settings)
After=multi-user.target
Wants=multi-user.target

[Service]
Type=oneshot
RemainAfterExit=yes
{}

[Install]
WantedBy=multi-user.target
"#,
        exec_lines.join("\n")
    );

    std::fs::write(SERVICE_PATH, &unit).map_err(|e| {
        Error::Other(format!(
            "failed to write systemd service {}: {}",
            SERVICE_PATH, e
        ))
    })?;

    Ok(PathBuf::from(SERVICE_PATH))
}

/// Enable the bop-powersave service.
pub fn enable_service() -> Result<()> {
    let status = std::process::Command::new("systemctl")
        .args(["daemon-reload"])
        .status()
        .map_err(|e| Error::Other(format!("systemctl daemon-reload failed: {}", e)))?;

    if !status.success() {
        return Err(Error::Other("systemctl daemon-reload failed".to_string()));
    }

    let status = std::process::Command::new("systemctl")
        .args(["enable", "bop-powersave.service"])
        .status()
        .map_err(|e| Error::Other(format!("systemctl enable failed: {}", e)))?;

    if !status.success() {
        return Err(Error::Other(
            "systemctl enable bop-powersave.service failed".to_string(),
        ));
    }

    Ok(())
}

/// Disable and remove the bop-powersave service.
pub fn remove_service() -> Result<()> {
    let service_path = Path::new(SERVICE_PATH);

    if service_path.exists() {
        let _ = std::process::Command::new("systemctl")
            .args(["disable", "bop-powersave.service"])
            .status();

        let _ = std::process::Command::new("systemctl")
            .args(["stop", "bop-powersave.service"])
            .status();

        std::fs::remove_file(service_path)
            .map_err(|e| Error::Other(format!("failed to remove {}: {}", SERVICE_PATH, e)))?;

        let _ = std::process::Command::new("systemctl")
            .args(["daemon-reload"])
            .status();
    }

    Ok(())
}
